Terraform
===========
setup

variables

data types

conditions -> expression ? "true-value": "false-value"

loops
	count based -> list
	for each -> set/map
	dynamic block

functions -> in built functions

data sources -> query the existing information  from provider

locals -> store expressions, functions. we can reuse them. cant override these values. we can variables inside locals

state -> matching desired infra with actual infra using state

remote state -> keep the state secure, for collaboration as well. locking it

provisioners -> when we create ec2 instances we can use provisioners to configure or perform next actions

local-exec -> runs the commands in local i.e where terraform command is executed

provisioner "local-exec" {
	command = ""
	on_failure = continue
	when = destroy
}

remote-exec
=============
terraform can connect to ec2 instance and configure it using remote-exec. basically running commands inside the server

How to create multiple environments using terraform
===================================================
1. using .tfvars
2. terraform workspaces
3. individual repos

tfvars
========
override the default values of the variables

DEV and PROD

in terraform everything is fix , we can change only values.

tags
=====
common tags
	Project = Roboshop
	Terraform = true

separate tags
	component = catalogue
	Environment = dev/prod
	
Terraform Workspace
=====================
terraform.workspace = dev

lookup(map, key, default)

maintain different repos for different environments
================================
roboshop-infra-dev
roboshop-infra-prod

Modules development
===================
if separate code for each component, there is no single point of control

--> If there is version change, we need to update in all components
--> There are no common standards for all the projects
--> Maintenance and update is very tough

module advantages
=================
1. changes at single place cascade to all components using that module -> centralised approach
2. we can implement industry best standards in the module, all other components are forced to use. better for governance, compliance and auditing
3. code reuse


terraform naming conventions
===========================
terraform naming convention
===========================
sivakumar_reddy_m -> for programs

sivakumar-reddy-m -> for humans

human ramesh
ramesh

catalogue-instance -> resource type should not be used in resource names
id -> string
ids -> list

module "module-name" {

	source = ""
	mandatory-variables
}

=================================================================================================
Module -> must provide inputs and outputs documentation. Module must provide outputs
Infra code -> provider, have to pass inputs to module. Must receive outputs

module "module_name" {

	source = ""
	module_vars = "values"
}

VPC(Virtual private cloud) -> where we can our resources in isolated space. we have the full control over this. we are completely responsible to this
=========================
pincode
street name/number
door number

PINCODE-STREET_NUMBER-DOOR/APT_NUMBER-FLOOR_NUMBER-FLAT_NUMBER

534673-33-25-03-302

534674-33

one room
power connection
network connection
AC
physical security

Subnets -> we create partitions in network for maintainance and security. 

VPC -> Village
Subnet -> Streets
Route tables -> Roads
Internet Gateway -> Modem/Arch


=======================================================================================
IP Address

192.168.0.1 -> 32 bits
 
0 1 2 3 . . . . 9 -> binary
0 1 -> Binary

2   1   0
=	=	=
1	2	4 = 4*10^0 + 2*10^1 + 1*10^2 = 4+20+100

4 Octates -> 8 bits each = 32 bits

7	6	5	4	3	2	1	0
=	=	=	=	=	=	=	=
1	0	0	1	0	1	0	1 = 1*2^0 + 0*2^1 + 1*2^2 + 0*2^3 + 1*2^4 + 0*2^5 + 0*2^6 + 1*2^7
							  = 1 + 0 + 4 + 0 + 16 + 0 + 0 + 128
							  = 149
							  
00000000 -> 0
11111111 -> 255

255.255.255.255

_ -> 0 1 -> 2^1 = 2

_	_
0	0
0	1
1	0
1	1
-> 2^2 = 4

n bits -> how many numbers -> 2^n
32 bits ipv4 -> 2^32

NAT -> public IP from ISP

IP = Network+Host(server)

10.0.0.0/16 -> first 16 bits are reserved for network. next 16 bits are reserved for hostinger

10.0.0.0
.
.
.	= 2^16 = 65,536
.	
.
10.0.255.255

CIDR = Classless Inter Domain Routing

10.0.0.0/16 == pincode

2^8 -> 256 subnets

10.0.0.0/24 -> 24 bits are reserved. 2^8 = 256 = 0-255
10.0.0.0
.
.
.
10.0.0.255

10.0.0.0/24
10.0.1.0/24
10.0.2.0/24
10.0.3.0/24
.
.
.
.
10.0.255.0/24



10.0.1.0/24 -> public-1a
10.0.2.0/24 -> public-1b

10.0.11.0/24 -> private-1a
10.0.12.0/24 -> private-1b

0.0.0.0/0

private server -> no internet access

dnf install mysql-server -> traffic is originating inside server -> egress
backend connecting DB -> ingress

What is NAT gateway?

If we want to enable egress internet access to the private servers we can enable NAT gateway. for installation, patches, etc.

Elastic IP == Static IP = 1500INR

VPC -> CIDR
IGW
Subnets -> CIDR
Route tables and Routes
Route table associations with subnets
EIP
NAT gateway

Public and Private subnets
NAT in public
bastion host in seperate subnet
VPN in different subnet

Lap -> VPN -> VPN IP is enabled in private subnet. NAT for internet
Bastion can access private EC2 -> NACL attached to private subnet should allow bastion subnet CIDR or IP
NACL

